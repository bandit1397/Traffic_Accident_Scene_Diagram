<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Traffic Accident Scene Diagram</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body { margin:0; background:#eee; font-family:sans-serif; }

#container {
  position: relative;
  width: 210mm;     /* A4 ì„¸ë¡œ ê°€ë¡œ */
  height: 270mm;     
  margin: 0 auto;
  padding: 15mm;    /* ì‚¬ì§„ê³¼ ìœ ì‚¬í•œ ì—¬ë°± */
  background: #fff;
  border: 1px solid #000;
  box-sizing: border-box;

  touch-action: none;              /* â­ í•€ì¹˜ ì¤Œ í—ˆìš© */
  transform-origin: center center; /* â­ í™•ëŒ€ ê¸°ì¤€ */
}



h1 {
  text-align: center;
  font-size: 16px;
  margin: 0 0 10mm 0;   /* â­ ì œëª© ì•„ë˜ ì—¬ë°± */
}

#map {
  width: 100%;
  height: calc(100% - 30mm - 26px);
  /* padding ìƒí•˜ + ì œëª© ì˜ì—­ ì œì™¸ */
  border: 1px solid #000;
  position: relative;
  overflow: hidden;
}

/* ===== ì¹´ì¹´ì˜¤ ì§€ë„ ì´ë¯¸ì§€ ===== */
#bgMap {
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:contain;
  user-select:none;
  pointer-events:none;
  z-index:1;
}

#lineLayer{
  position:absolute;
  top:0;
  left:0;
  width:100%;
  height:100%;
  z-index:400;
  pointer-events:auto;
}

/* ===== ììœ ê³¡ì„  ìº”ë²„ìŠ¤ ===== */
#drawCanvas {
  position:absolute;
  inset:0;
  z-index:500;
}

/* ===== ê°ì²´ ===== */
.icon, .arrow {
  position:absolute;
  cursor:move;
  z-index:1000;
}

/* ===== ê°ì²´ ì „ìš© ë ˆì´ì–´ (map ë°– í—ˆìš©) ===== */
#objectLayer{
  position:absolute;
  inset:0;
  z-index:2000;
  pointer-events:none;   /* ê¸°ë³¸ í†µê³¼ */
}

#objectLayer .icon,
#objectLayer .arrow,
#objectLayer .textbox{
  pointer-events:auto;   /* ê°ì²´ë§Œ ì´ë²¤íŠ¸ */
}

.arrow { transform-origin:center; }

.textbox {
  position:absolute;
  border:1px solid transparent;
  background:#fff;
  padding:2px 4px;
  cursor:move;
  z-index:1000;

  resize:none;          /* â­ ì œê±° */
  white-space:nowrap;  /* â­ í•œ ì¤„ ìœ ì§€ */
}

/* ===== ì†ì„± íŒ¨ë„ ===== */
#panel {
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%, -50%);
  background:#fff;
  border:1px solid #333;
  padding:10px;
  width:200px;
  visibility:hidden;
  opacity:0;
  z-index:3000;
}


#panelHeader {
  font-weight: bold;
  margin-bottom: 6px;
  cursor: move;
  user-select: none;
}

#panel, #panelHeader {
  touch-action: none;
}

#panel label {
  font-size:12px;
  display:block;
  margin-top:6px;
}

#panel input[type="range"]{
  width:100%;
}

.rangeWrap{
  display:flex;
  align-items:center;
  gap:4px;
}

.stepBtn{
  width:22px;
  height:22px;
  font-size:16px;
  line-height:20px;
  padding:0;
  cursor:pointer;
}

/* ===== ë„êµ¬ íŒ¨ë„ ===== */
#toolbox {
  position:absolute;
  top:10px;
  left:10px;
  z-index:4000;
}

#toolToggle {
  width:44px;
  height:44px;
  font-size:22px;
  border-radius:8px;
  background:#333;
  color:#fff;
  border:none;
}

#toolContent {
  display:none;
  margin-top:6px;
  background:#fff;
  border:1px solid #333;
  border-radius:10px;
  padding:6px;
  width:120px;

  max-height: 70vh;
  overflow-y: auto;
  overscroll-behavior: contain;

  padding-bottom: 16px;        /* âœ… PC ìŠ¤í¬ë¡¤ ì˜ë¦¼ ë°©ì§€ */
  box-sizing: border-box;      /* âœ… ë†’ì´ ê³„ì‚° ì •í™•í™” */
}


#toolContent button {
  width:100%;
  min-height:32px;
  margin:2px 0;
  font-size:13px;
}

#toolContent label {
  font-size:12px;
  display:block;
  margin-top:4px;
}

#toolContent hr {
  margin:6px 0;
}
.subToggle{
  width:100%;
  min-height:32px;
  margin:2px 0;
  font-size:13px;
  text-align:left;
}

.subMenu{
  display:none;
  padding-left:8px;
}

.subMenu button{
  font-size:12px;
}

</style>
</head>

<body>

<div id="container">
  <h1>êµí†µì‚¬ê³  í˜„ì¥ì•½ë„</h1>

  <div id="map">


    <!-- ë°°ê²½ ì§€ë„ ì´ë¯¸ì§€ -->
    <img id="bgMap"
       src="kakao_capture.jpg"
       style="
         position:absolute;
         inset:0;
         width:100%;
         height:100%;
         object-fit:cover;   /* â­ contain â†’ cover ë³€ê²½ */
         z-index:1;
         pointer-events:none;
       ">

  </div>

  <!-- ğŸŸ¢ ì‹¤ì„  / ì ì„ ìš© SVG (ì¢Œí‘œ ì •í™•) -->
    <svg id="lineLayer"
         width="100%"
         height="100%"
         style="
           position:absolute;
           inset:0;
           z-index:400;
           touch-action:none;
           pointer-events:auto;
           background:transparent;
         ">
    </svg>

  <div id="objectLayer"></div>

    <!-- â‘£ ì†ì„± íŒ¨ë„ -->
    <div id="panel">

      <div id="panelHeader">ì„ íƒ ê°ì²´</div>

      <label>ê°ë„
        <div class="rangeWrap">
          <button class="stepBtn" data-target="angle" data-step="-0.2">âˆ’</button>
          <input id="angle" type="range" min="-180" max="180" step="0.2" value="0">
          <button class="stepBtn" data-target="angle" data-step="0.2">+</button>
        </div>
      </label>
      <label>í¬ê¸°
        <input id="size" type="range" min="10" max="150" value="32">
      </label>
      <label>ê¸€ìí¬ê¸°
        <input id="fontSize" type="range" min="8" max="48" value="14">
      </label>
      <label>í­
        <input id="width" type="range" min="10" max="300" value="60">
      </label>
    </div>


    <!-- ë„êµ¬ -->
    <!-- ë„êµ¬ -->
    <div id="toolbox">
      <button id="toolToggle">â˜°</button>

      <div id="toolContent">

        <!-- ===== ê°ì²´ ===== -->
        <button onclick="togglePanel()">ê°ì²´íŒ¨ë„</button>
        <button onclick="addIcon('person')">ì‚¬ëŒ</button>
        <button onclick="addIcon('car')">ìë™ì°¨</button>
        <button onclick="addIcon('bike')">ìì „ê±°</button>

        <!-- ===== ì˜¤í† ë°”ì´ í•˜ìœ„ í† ê¸€ ===== -->
        <button class="subToggle" onclick="toggleSub('motoMenu', this)">â–¶ ì˜¤í† ë°”ì´</button>
        <div id="motoMenu" class="subMenu">
          <button onclick="addMoto(0)">ì˜¤í† ë°”ì´â‘ </button>
          <button onclick="addMoto(1)">ì˜¤í† ë°”ì´â‘¡</button>
          <button onclick="addMoto(2)">ì˜¤í† ë°”ì´â‘¢</button>
        </div>

        <!-- ===== í™”ì‚´í‘œ í•˜ìœ„ í† ê¸€ ===== -->
        <button class="subToggle" onclick="toggleSub('arrowMenu', this)">â–¶ í™”ì‚´í‘œ</button>
        <div id="arrowMenu" class="subMenu">
          <button onclick="addArrow(0)">í™”ì‚´í‘œâ‘ </button>
          <button onclick="addArrow(1)">í™”ì‚´í‘œâ‘¡</button>
          <button onclick="addArrow(2)">í™”ì‚´í‘œâ‘¢</button>
          <button onclick="addArrow(3)">í™”ì‚´í‘œâ‘£</button>
          <button onclick="addArrow(4)">í™”ì‚´í‘œâ‘¤</button>
        </div>

        <button onclick="addText()">ë¬¸ì</button>

        <hr>

        <!-- ===== ì„ ìƒ‰ / êµµê¸° ===== -->
        <label>
          ì„ ìƒ‰
          <input type="color" id="lineColor" value="#ff0000">
        </label>

        <label>
          êµµê¸°
          <input type="range" id="lineWidth" min="1" max="15" value="3">
        </label>

        <button onclick="savePDF()">PDF</button>

        <hr>

        <!-- ===== ì„  í•˜ìœ„ í† ê¸€ ===== -->
        <button class="subToggle" onclick="toggleSub('lineMenu', this)">â–¶ ì„ </button>

        <div id="lineMenu" class="subMenu">

          <b style="font-size:12px;">ì„  ì„ íƒ</b>
          <button onclick="setLineMode('solid')">ì‹¤ì„  ì„ íƒ</button>
          <button onclick="setLineMode('dashed')">ì ì„  ì„ íƒ</button>
          <button onclick="setLineMode(null)">ì„  í•´ì œ</button>

          <hr>

          <b style="font-size:12px;">ì„  ì´ë™</b>
          <button onclick="setMoveMode('solid')">ì‹¤ì„  ì´ë™</button>
          <button onclick="setMoveMode('dashed')">ì ì„  ì´ë™</button>

          <hr>

          <b style="font-size:12px;">ì„  ì‚­ì œ</b>
          <button onclick="setDeleteMode('solid')">ì‹¤ì„  ì‚­ì œ</button>
          <button onclick="setDeleteMode('dashed')">ì ì„  ì‚­ì œ</button>

          <hr>

          <b style="font-size:12px;">ì„  íšŒì „ ê¸°ì¤€</b>
          <button onclick="lineRotateAnchor='start'">ì¢Œì¸¡ ê¸°ì¤€</button>
          <button onclick="lineRotateAnchor='end'">ìš°ì¸¡ ê¸°ì¤€</button>

        </div>

        <hr>

        <!-- ===== ë°°ê²½ ì´ë¯¸ì§€ ===== -->
        <label style="font-size:12px; display:block; margin-top:6px;">
          ë°°ê²½ ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸°
          <input type="file" id="bgInput" accept="image/*">
        </label>

      </div>
    </div>

  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
const mapDiv = document.getElementById('map');
const panel = document.getElementById('panel');

const objectLayer = document.getElementById('objectLayer');

async function cropImageToMapCover(imgEl, mapEl, outScale = 2){
  // map í¬ê¸°(í™”ë©´ px ê¸°ì¤€)
  const r = mapEl.getBoundingClientRect();
  const cw = Math.round(r.width);
  const ch = Math.round(r.height);

  // ì›ë³¸ ì´ë¯¸ì§€ ì‹¤ì œ í¬ê¸°
  const iw = imgEl.naturalWidth;
  const ih = imgEl.naturalHeight;

  // "cover" ìŠ¤ì¼€ì¼ (ì»¨í…Œì´ë„ˆë¥¼ ê½‰ ì±„ìš°ëŠ” ìŠ¤ì¼€ì¼)
  const scale = Math.max(cw / iw, ch / ih);

  // ì»¨í…Œì´ë„ˆì— ë³´ì´ëŠ” ì˜ì—­ì´ ì›ë³¸ì—ì„œ ì°¨ì§€í•˜ëŠ” í¬ê¸°(ì†ŒìŠ¤ ì¢Œí‘œ)
  const srcW = cw / scale;
  const srcH = ch / scale;

  // ì¤‘ì•™ í¬ë¡­(ì›ë³¸ ê°€ìš´ë°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ)
  const sx = (iw - srcW) / 2;
  const sy = (ih - srcH) / 2;

  // ì¶œë ¥ ìº”ë²„ìŠ¤(í•´ìƒë„ outScaleë¡œ ì˜¬ë¦¬ë©´ PDF ë” ì„ ëª…)
  const canvas = document.createElement('canvas');
  canvas.width  = cw * outScale;
  canvas.height = ch * outScale;

  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = true;

  // ì›ë³¸ì—ì„œ sx,sy,srcW,srcHë§Œ ì˜ë¼ì„œ
  // ì¶œë ¥ ìº”ë²„ìŠ¤ ì „ì²´ë¡œ í™•ëŒ€í•´ì„œ ê·¸ë¦¼
  ctx.drawImage(
    imgEl,
    sx, sy, srcW, srcH,
    0, 0, canvas.width, canvas.height
  );

  return canvas.toDataURL('image/jpeg', 0.95); // pngë„ ê°€ëŠ¥
}


// ===== ì—¬ê¸°! =====
function enableDeleteConfirmation(el) {
    let touchTimer = null;
    let startX = 0, startY = 0;
    let moved = false;
    const MOVE_THRESHOLD = 6; // â­ ì´ ê±°ë¦¬ ì´ìƒ ì›€ì§ì´ë©´ "ì´ë™"ìœ¼ë¡œ íŒë‹¨

    // PC: ë”ë¸”í´ë¦­ ì‚­ì œ (ê¸°ì¡´ ê·¸ëŒ€ë¡œ)
    el.addEventListener('dblclick', e => {
        e.preventDefault();
        if(confirm('ì´ ê°ì²´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            el.remove();
            if(selected === el){
                selected = null;
                panel.style.visibility = 'hidden';
                panel.style.opacity = '0';
            }
        }
    });

    // ëª¨ë°”ì¼: ê¸¸ê²Œ ëˆ„ë¥´ê¸° ì‹œì‘
    el.addEventListener('pointerdown', e => {
        if(e.pointerType !== 'touch') return;

        startX = e.clientX;
        startY = e.clientY;
        moved = false;

        touchTimer = setTimeout(() => {
            if(moved) return; // â­ ì´ë™ ì¤‘ì´ë©´ ì‚­ì œ ê¸ˆì§€

            if(confirm('ì´ ê°ì²´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                el.remove();
                if(selected === el){
                    selected = null;
                    panel.style.visibility = 'hidden';
                    panel.style.opacity = '0';
                }
            }
        }, 700);
    });

    // â­ ì´ë™ ê°ì§€ â†’ ì‚­ì œ íƒ€ì´ë¨¸ ì·¨ì†Œ
    el.addEventListener('pointermove', e => {
        if(!touchTimer) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        if(Math.hypot(dx, dy) > MOVE_THRESHOLD) {
            moved = true;
            clearTimeout(touchTimer);
            touchTimer = null;
        }
    });

    // í„°ì¹˜ ì¢…ë£Œ / ì·¨ì†Œ
    el.addEventListener('pointerup', () => {
        if(touchTimer){
            clearTimeout(touchTimer);
            touchTimer = null;
        }
    });

    el.addEventListener('pointercancel', () => {
        if(touchTimer){
            clearTimeout(touchTimer);
            touchTimer = null;
        }
    });
}


// ì„  ìƒ‰ê³¼ ë‘ê»˜ ì´ˆê¸°ê°’
let currentLineColor = document.getElementById('lineColor').value;  // ê¸°ë³¸ ë¹¨ê°•
let currentLineWidth = document.getElementById('lineWidth').value;  // ê¸°ë³¸ 3

/* ===== ì„ (SVG) ì‹œìŠ¤í…œ ===== */
const svg = document.getElementById('lineLayer');

let lineMode = null;     // 'solid' | 'dashed' | null
let moveMode = null;
let deleteMode = null;

let startPoint = null;
let selectedLine = null;
let dragOffset = {x:0,y:0};

/* ===== ì„  ëª¨ë“œ ì œì–´ ===== */
function setLineMode(type){
  lineMode = type;
  moveMode = deleteMode = null;
  updateLineButtons();
}

function setMoveMode(type){
  moveMode = type;
  lineMode = deleteMode = null;
  updateLineButtons();
}

function setDeleteMode(type){
  deleteMode = type;
  lineMode = moveMode = null;
  updateLineButtons();
}


/* ===== ë²„íŠ¼ ìƒíƒœ í‘œì‹œ ===== */
function updateLineButtons(){
  const buttons = toolContent.querySelectorAll('button');

  buttons.forEach(btn => {
    btn.style.background = '#fff';   // ê¸°ë³¸ í°ìƒ‰
    btn.style.color = '#000';        // ê¸°ë³¸ ê²€ì€ìƒ‰
  });

  // í™œì„± ëª¨ë“œì— í•´ë‹¹í•˜ëŠ” ë²„íŠ¼ë§Œ ê°•ì¡°
  if(lineMode){
    const btn = toolContent.querySelector(`button[onclick="setLineMode('${lineMode}')"]`);
    if(btn){
      btn.style.background = '#333';
      btn.style.color = '#fff';
    }
  }
  if(moveMode){
    const btn = toolContent.querySelector(`button[onclick="setMoveMode('${moveMode}')"]`);
    if(btn){
      btn.style.background = '#333';
      btn.style.color = '#fff';
    }
  }
  if(deleteMode){
    const btn = toolContent.querySelector(`button[onclick="setDeleteMode('${deleteMode}')"]`);
    if(btn){
      btn.style.background = '#333';
      btn.style.color = '#fff';
    }
  }
}


/* ===== ì„  ì…ë ¥ ì´ë²¤íŠ¸ (â† ë°”ë¡œ ë‹¤ìŒì— ì§ˆë¬¸í•œ ì½”ë“œê°€ ì˜´) ===== */
svg.addEventListener('pointerdown', e=>{
  const pt = getSVGPoint(e);

  /* ===== ìƒì„± ===== */
  if(lineMode){
    if(!startPoint){
      startPoint = pt;
    }else{
      createLine(startPoint, pt, lineMode);
      startPoint = null;
    }
  }

  /* ===== ì‚­ì œ ===== */
  if(deleteMode){
    const line = findNearestLine(pt, deleteMode);
    if(line) svg.removeChild(line);
  }

  /* ===== ì´ë™ ì‹œì‘ ===== */
  if(moveMode){
    const line = findNearestLine(pt, moveMode);
    if(line){
      selectedLine = line;
      dragOffset = {
        x: pt.x - line.x1.baseVal.value,
        y: pt.y - line.y1.baseVal.value
      };
      svg.setPointerCapture(e.pointerId);
    }
  }
  // ì„  ì„ íƒ
  if(!lineMode && !moveMode && !deleteMode){
    const line = findNearestLine(pt, 'solid') || findNearestLine(pt, 'dashed');
    if(line) select(line);
  }
});

/* ===== ì„  ì´ë™ ===== */
svg.addEventListener('pointermove', e=>{
  if(!selectedLine) return;

  const pt = getSVGPoint(e);
  const dx = pt.x - dragOffset.x;
  const dy = pt.y - dragOffset.y;

  const w = selectedLine.x2.baseVal.value - selectedLine.x1.baseVal.value;
  const h = selectedLine.y2.baseVal.value - selectedLine.y1.baseVal.value;

  selectedLine.setAttribute('x1', dx);
  selectedLine.setAttribute('y1', dy);
  selectedLine.setAttribute('x2', dx + w);
  selectedLine.setAttribute('y2', dy + h);
});

/* ===== ì´ë™ ì¢…ë£Œ ===== */
svg.addEventListener('pointerup', ()=>{
  selectedLine = null;
});

/* ===== ì¢Œí‘œ ë³€í™˜ ===== */
const container = document.getElementById('container');

function getSVGPoint(e){
  const r = container.getBoundingClientRect();
  return {
    x: e.clientX - r.left,
    y: e.clientY - r.top
  };
}


/* ===== ì„  ìƒì„± ===== */
function createLine(p1, p2, type){
  const line = document.createElementNS(
    'http://www.w3.org/2000/svg',
    'line'
  );

  line.setAttribute('x1', p1.x);
  line.setAttribute('y1', p1.y);
  line.setAttribute('x2', p2.x);
  line.setAttribute('y2', p2.y);
  line.setAttribute('stroke', currentLineColor);
  line.setAttribute('stroke-width', currentLineWidth);
  line.setAttribute('stroke-linecap', 'round');

  if(type === 'dashed'){
    line.setAttribute('stroke-dasharray', '8 6');
  }

  line.dataset.type = type;
  svg.appendChild(line);
}

document.getElementById('lineWidth').addEventListener('input', e=>{
  currentLineWidth = e.target.value;
  if(selected && selected.tagName === 'line'){
    selected.setAttribute('stroke-width', currentLineWidth);
  }
});

document.getElementById('lineColor').addEventListener('input', e=>{
  currentLineColor = e.target.value;
  if(selected && selected.tagName === 'line'){
    selected.setAttribute('stroke', currentLineColor);
  }
});


/* ===== ê°€ì¥ ê°€ê¹Œìš´ ì„  ì°¾ê¸° ===== */
function findNearestLine(pt, type){
  let min = 15;
  let target = null;

  [...svg.children].forEach(l=>{
    if(l.dataset.type !== type) return;
    const d = pointLineDistance(pt, l);
    if(d < min){
      min = d;
      target = l;
    }
  });
  return target;
}

/* ===== ì -ì„  ê±°ë¦¬ ê³„ì‚° ===== */
function pointLineDistance(p, l){
  const x1=l.x1.baseVal.value, y1=l.y1.baseVal.value;
  const x2=l.x2.baseVal.value, y2=l.y2.baseVal.value;
  const A=p.x-x1, B=p.y-y1, C=x2-x1, D=y2-y1;
  const dot=A*C+B*D;
  const len=C*C+D*D;
  const t=Math.max(0,Math.min(1,dot/len));
  const x=x1+t*C, y=y1+t*D;
  return Math.hypot(p.x-x,p.y-y);
}
  
function togglePanel(){
  if(panel.style.visibility === 'visible'){
    panel.style.visibility = 'hidden';
    panel.style.opacity = '0';
  } else {
    // ğŸ”¹ í˜„ì¬ í™”ë©´ ê¸°ì¤€ ìœ„ì¹˜ë¥¼ pxë¡œ ê³ ì •
    const r = panel.getBoundingClientRect();
    const mapR = mapDiv.getBoundingClientRect();

    panel.style.left = (r.left - mapR.left) + 'px';
    panel.style.top  = (r.top  - mapR.top ) + 'px';
    panel.style.transform = 'none';   // â­ transform ì™„ì „ ì œê±°

    panel.style.visibility = 'visible';
    panel.style.opacity = '1';
  }
}

  
const panelHeader = document.getElementById('panelHeader');
drag(panelHeader, panel);


/* ===== ê³µí†µ ===== */
const icons = {
  person: './icons/person.png',
  car: './icons/car.png',
  bike: './icons/bike.png',
  motos: [
    './icons/moto1.png',
    './icons/moto2.png',
    './icons/moto3.png'
  ],
  arrows: [
    './icons/arrow1.png',
    './icons/arrow2.png',
    './icons/arrow3.png',
    './icons/arrow4.png',
    './icons/arrow5.png'
  ]
};


let selected=null;
let panelInitialized = false;
 
function centerPos(){
  const r = container.getBoundingClientRect();
  return {
    x: r.width / 2 - 32,
    y: r.height / 2 - 32
  };
}


function select(el){
  if(el === panel) return;
  selected = el;

  // ì„ ì´ë©´ íŒ¨ë„ ìŠ¬ë¼ì´ë” ì—°ë™
  if(el.tagName === 'line'){
    // ìƒ‰ìƒ/êµµê¸° íŒ¨ë„ ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸
    document.getElementById('lineColor').value = el.getAttribute('stroke');
    document.getElementById('lineWidth').value = el.getAttribute('stroke-width');
  }

  if(!panelInitialized){
    const r = mapDiv.getBoundingClientRect();
    panel.style.left = (r.width/2 - panel.offsetWidth/2) + 'px';
    panel.style.top  = (r.height/2 - panel.offsetHeight/2) + 'px';
    panel.style.transform = 'none';
    panelInitialized = true;
  }

  panel.style.visibility = 'visible';
  panel.style.opacity = '1';
}




/* ===== ë“œë˜ê·¸ ===== */
function drag(handle, target = handle){
  let sx = 0, sy = 0, ox = 0, oy = 0;
  let dragging = false;

  handle.style.touchAction = 'none';

  handle.addEventListener('pointerdown', e=>{

    if(target === panel && panel.style.transform){
      panel.style.transform = 'none';
    }

    if(typeof select === 'function'){
      select(target);
    }

    if(target.classList.contains('textbox') && target.isEditing){
      return;
    }

    dragging = true;
    sx = e.clientX;
    sy = e.clientY;
    ox = parseFloat(target.style.left) || 0;
    oy = parseFloat(target.style.top)  || 0;

    handle.setPointerCapture(e.pointerId);
    e.preventDefault();
  });


  handle.addEventListener('pointermove', e=>{
    if(!dragging) return;

    target.style.left = (ox + e.clientX - sx) + 'px';
    target.style.top  = (oy + e.clientY - sy) + 'px';
  });

  handle.addEventListener('pointerup', e=>{
    dragging = false;
    handle.releasePointerCapture(e.pointerId);
  });

  handle.addEventListener('pointercancel', e=>{
    dragging = false;
    handle.releasePointerCapture(e.pointerId);
  });
}


/* ===== ê°ì²´ ===== */
function addIcon(type){
  const p=centerPos();
  const img=document.createElement('img');
  img.src=icons[type];
  img.className='icon';
  img.style.left=p.x+'px';
  img.style.top=p.y+'px';
  img.style.width = '64px'; 
  objectLayer.appendChild(img);
  drag(img);
  enableDeleteConfirmation(img);  // ğŸ”¹ ì—¬ê¸° ì¶”ê°€
}

function addMoto(index = 0){
  const p = centerPos();
  const img = document.createElement('img');

  img.src = icons.motos[index];
  img.className = 'icon';

  img.style.left = p.x + 'px';
  img.style.top  = p.y + 'px';
  img.style.width = '64px';

  objectLayer.appendChild(img);
  drag(img);
  enableDeleteConfirmation(img);
}


function addArrow(type = 0){
  const p = centerPos();
  const img = document.createElement('img');

  img.src = icons.arrows[type];   // â­ ì—¬ê¸°ë§Œ ë³€ê²½
  img.className = 'arrow';

  img.style.left = p.x + 'px';
  img.style.top  = p.y + 'px';
  img.style.width = '64px';

  objectLayer.appendChild(img);
  drag(img);
  enableDeleteConfirmation(img);
}


function addText(){
  const p = centerPos();
  const t = document.createElement('input');

  t.type = 'text';
  t.className = 'textbox';
  t.placeholder = 'í…ìŠ¤íŠ¸';

  t.isEditing = false;       // â­ ìƒíƒœ í”Œë˜ê·¸
  t.readOnly = true;

  t.style.left = p.x + 'px';
  t.style.top  = p.y + 'px';
  t.style.fontSize = '20px';
  t.style.textAlign = 'center';
  t.style.width = '20px';

  objectLayer.appendChild(t);
  drag(t);
  enableDeleteConfirmation(t);  // ğŸ”¹ ì—¬ê¸° ì¶”ê°€

  

  /* ğŸ”¹ ëª¨ë°”ì¼ íƒ­ â†’ í¸ì§‘ */
let touchMoved = false;

t.addEventListener('pointerdown', () => {
  touchMoved = false;
});

t.addEventListener('pointermove', () => {
  touchMoved = true;   // ì´ë™í•˜ë©´ í¸ì§‘ ì·¨ì†Œ
});

t.addEventListener('pointerup', () => {
  if (touchMoved) return;        // ë“œë˜ê·¸ ì¤‘ì´ë©´ ë¬´ì‹œ
  if (t.isEditing) return;

  // ëª¨ë°”ì¼ì—ì„œ í¸ì§‘ ì‹œì‘
  t.isEditing = true;
  t.readOnly = false;
  t.style.borderColor = '#333';
  t.focus();
  adjustSize();

  // ëª¨ë°”ì¼ í‚¤ë³´ë“œ í™•ì‹¤íˆ ë„ìš°ê¸°
  setTimeout(() => {
    t.setSelectionRange(t.value.length, t.value.length);
  }, 0);
});


  /* ğŸ”¹ ìë™ í­ ê³„ì‚° */
  const adjustSize = ()=>{
    t.style.width = '1px';
    t.style.width = (t.scrollWidth + 6) + 'px';
  };

  /* ğŸ”¹ ë”ë¸”í´ë¦­ â†’ í¸ì§‘ */
  t.addEventListener('dblclick', ()=>{
    t.isEditing = true;
    t.readOnly = false;
    t.focus();
    adjustSize();
  });

  /* ğŸ”¹ ì…ë ¥ ì¤‘ ìë™ í™•ëŒ€ */
  t.addEventListener('input', adjustSize);

  /* ğŸ”¹ í¬ì»¤ìŠ¤ í•´ì œ â†’ ì´ë™ */
  t.addEventListener('blur', ()=>{
    t.isEditing = false;
    t.readOnly = true;
    t.style.borderColor = 'transparent';
    adjustSize();
  });

  /* ğŸ”¹ í°íŠ¸ ìŠ¬ë¼ì´ë” ì—°ë™ */
  const fontInput = document.getElementById('fontSize');
  fontInput.addEventListener('input', ()=>{
    if(selected === t){
      t.style.fontSize = fontInput.value + 'px';
      adjustSize();
    }
  });

  adjustSize();
}

/* ===== PDF ===== */
async function savePDF(){
  const canvasImg = await html2canvas(container, {
    ignoreElements: (el) => {
      return el.id === 'toolbox' || el.closest('#toolbox');
    }
  });

  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF('p','mm','a4');
  const w = pdf.internal.pageSize.getWidth();
  const h = canvasImg.height * w / canvasImg.width;

  pdf.addImage(canvasImg.toDataURL('image/png'), 'PNG', 0, 0, w, h);
  pdf.save('Traffic_Accident_Scene_Diagram.pdf');
}


function toggleSub(id){
  const el = document.getElementById(id);
  const isVisible = window.getComputedStyle(el).display !== 'none';
  el.style.display = isVisible ? 'none' : 'block';
}



/* ===== ë„êµ¬ í† ê¸€ ===== */
const toolToggle  = document.getElementById('toolToggle');
const toolContent = document.getElementById('toolContent');

toolToggle.onclick = () => {
  toolContent.style.display =
    toolContent.style.display === 'block' ? 'none' : 'block';
};

// ===== í•˜ìœ„ ë©”ë‰´ í† ê¸€ =====
function toggleSub(id, btn){
  const el = document.getElementById(id);
  const isVisible = el.style.display === 'block';
  el.style.display = isVisible ? 'none' : 'block';

  // ë²„íŠ¼ í…ìŠ¤íŠ¸ ì• ê¸€ìë§Œ ë°”ê¾¸ê¸°
  if(btn){
    const label = btn.textContent.slice(2);  // 'ì„ ', 'ì˜¤í† ë°”ì´' ë“±
    btn.textContent = (isVisible ? 'â–¶ ' : 'â–¼ ') + label;
  }
}



/* ===== ë°°ê²½ ì´ë¯¸ì§€ ì„ íƒ ===== */
const bgMap = document.getElementById('bgMap');
const bgInput = document.getElementById('bgInput');

// ë°°ê²½ ì´ë¯¸ì§€ ì„ íƒ ì½”ë“œ ë
bgInput.addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = async function(evt){
    // 1) ì¼ë‹¨ ì›ë³¸ì„ bgMapì— ë¡œë“œ
    bgMap.onload = async () => {
      // 2) map ì˜ì—­ì— ë§ì¶° "ë³´ì´ëŠ” ë¶€ë¶„ë§Œ" ì‹¤ì œ í¬ë¡­
      const cropped = await cropImageToMapCover(bgMap, mapDiv, 2);

      // 3) í¬ë¡­ëœ ì´ë¯¸ì§€ë¡œ êµì²´ â†’ ì´ì œ ìˆ¨ê²¨ì§„ ì˜ì—­ ìì²´ê°€ ì—†ìŒ
      bgMap.src = cropped;

      // 4) ì´ì œëŠ” cover í•„ìš” ì—†ìŒ (ì´ë¯¸ ë”± ë§ê²Œ ì˜ë¼ì ¸ ìˆìœ¼ë‹ˆê¹Œ)
      bgMap.style.objectFit = 'fill';
    };

    bgMap.src = evt.target.result;
  };
  reader.readAsDataURL(file);
});


/* ===== ì„ íƒ ê°ì²´ ì†ì„± íŒ¨ë„ ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸ ì—°ê²° ===== */
const angleInput    = document.getElementById('angle');
let lineRotateAnchor = 'start';   // 'start' = x1,y1 / 'end' = x2,y2
const sizeInput     = document.getElementById('size');
const fontSizeInput = document.getElementById('fontSize');
const widthInput    = document.getElementById('width');

angleInput.addEventListener('input', ()=> {
  if(!selected || selected === panel) return;

  // ===== ì„ ì¼ ê²½ìš° (ëì  ê¸°ì¤€ íšŒì „) =====
  if(selected.tagName === 'line'){
    const x1 = selected.x1.baseVal.value;
    const y1 = selected.y1.baseVal.value;
    const x2 = selected.x2.baseVal.value;
    const y2 = selected.y2.baseVal.value;

    const anchor =
      lineRotateAnchor === 'start'
        ? { x: x1, y: y1 }   // ì¢Œì¸¡ ëì 
        : { x: x2, y: y2 };  // ìš°ì¸¡ ëì 

    selected.style.transformOrigin =
      `${anchor.x}px ${anchor.y}px`;

    selected.style.transform =
      `rotate(${angleInput.value}deg)`;
  }
  // ===== ê¸°ì¡´ ê°ì²´(ì•„ì´ì½˜, í™”ì‚´í‘œ, ë¬¸ì) =====
  else{
    selected.style.transform =
      `rotate(${angleInput.value}deg)`;
  }
});

sizeInput.addEventListener('input', ()=> {
  if(!selected || selected === panel) return;
  selected.style.width = sizeInput.value + 'px';
  if(selected.tagName === 'IMG') selected.style.height = 'auto';
});

fontSizeInput.addEventListener('input', ()=> {
  if(!selected) return;
  if(selected.tagName === 'INPUT') selected.style.fontSize = fontSizeInput.value + 'px';
});

widthInput.addEventListener('input', ()=> {
  if(!selected || selected === panel) return;

  if(selected.tagName === 'INPUT') {
    selected.style.width = widthInput.value + 'px';
  } else if(selected.classList.contains('arrow')) {
    selected.style.width = widthInput.value + 'px';
    selected.style.height = 'auto';
  }
});

/* ===================================================== */
/* ===== + / - ìë™ ì¦ê° ë²„íŠ¼ (ìŠ¬ë¼ì´ë” ê¸°ëŠ¥ ì¬ì‚¬ìš©) ===== */
/* ===================================================== */

let stepTimer = null;

document.querySelectorAll('.stepBtn').forEach(btn=>{
  const targetId = btn.dataset.target;
  const step = parseFloat(btn.dataset.step);

  const start = ()=>{
    const input = document.getElementById(targetId);
    if(!input) return;

    const update = ()=>{
      let v = parseFloat(input.value) + step;
      v = Math.max(
        parseFloat(input.min),
        Math.min(parseFloat(input.max), v)
      );
      input.value = v;

      // â­ ê¸°ì¡´ ìŠ¬ë¼ì´ë” ë¡œì§ 100% ì¬ì‚¬ìš©
      input.dispatchEvent(new Event('input'));
    };

    update();                 // ì¦‰ì‹œ 1íšŒ
    stepTimer = setInterval(update, 80); // ê¸¸ê²Œ ëˆ„ë¥´ë©´ ìë™
  };

  const stop = ()=>{
    clearInterval(stepTimer);
    stepTimer = null;
  };

  btn.addEventListener('pointerdown', start);
  btn.addEventListener('pointerup', stop);
  btn.addEventListener('pointerleave', stop);
  btn.addEventListener('pointercancel', stop);
});

<script>
/* ============================= */
/* ===== A4 ì»¨í…Œì´ë„ˆ í•€ì¹˜ì¤Œ ===== */
/* ============================= */

const pinchTarget = document.getElementById('container');

let pointers = new Map();
let startDistance = 0;
let startScale = 1;
let currentScale = 1;

function getDistance(p1, p2){
  const dx = p1.clientX - p2.clientX;
  const dy = p1.clientY - p2.clientY;
  return Math.hypot(dx, dy);
}

pinchTarget.addEventListener('pointerdown', e=>{
  pointers.set(e.pointerId, e);
});

pinchTarget.addEventListener('pointermove', e=>{
  if(!pointers.has(e.pointerId)) return;
  pointers.set(e.pointerId, e);

  if(pointers.size === 2){
    const pts = [...pointers.values()];
    const dist = getDistance(pts[0], pts[1]);

    if(startDistance === 0){
      startDistance = dist;
      startScale = currentScale;
      return;
    }

    let scale = startScale * (dist / startDistance);

    /* â­ í™•ëŒ€/ì¶•ì†Œ ì œí•œ */
    scale = Math.min(2.5, Math.max(0.5, scale));

    currentScale = scale;
    pinchTarget.style.transform = `scale(${scale})`;
  }
});

pinchTarget.addEventListener('pointerup', e=>{
  pointers.delete(e.pointerId);
  if(pointers.size < 2){
    startDistance = 0;
  }
});

pinchTarget.addEventListener('pointercancel', ()=>{
  pointers.clear();
  startDistance = 0;
});
 
</script>

</body>
</html>
